import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, w as validate_each_argument, x as onMount, v as validate_slots, e as element, b as space, h as claim_element, j as children, f as claim_space, c as detach_dev, l as attr_dev, n as add_location, o as insert_dev, p as append_dev, r as listen_dev, u as noop, y as destroy_each, z as run_all, t as text, k as claim_text, A as create_component, B as claim_component, C as mount_component, D as transition_in, E as transition_out, F as destroy_component, G as group_outros, H as check_outros, q as query_selector_all, m as set_style } from './client.84926a16.js';

/* src\components\SlideShow.svelte generated by Svelte v3.23.0 */
const file = "src\\components\\SlideShow.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (29:16) {#each images as image}
function create_each_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let img_alt_value;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true });
			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = /*image*/ ctx[2])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*image*/ ctx[2]);
			add_location(img, file, 30, 24, 974);
			attr_dev(div, "class", "item column is-12");
			add_location(div, file, 29, 20, 917);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*images*/ 1 && img.src !== (img_src_value = /*image*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*images*/ 1 && img_alt_value !== (img_alt_value = /*image*/ ctx[2])) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(29:16) {#each images as image}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div4;
	let div0;
	let t0;
	let div3;
	let div2;
	let div1;
	let t1;
	let button;
	let mounted;
	let dispose;
	let each_value = /*images*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			t0 = space();
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			button = element("button");
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			button = claim_element(div4_nodes, "BUTTON", { class: true, "aria-label": true });
			children(button).forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-background");
			add_location(div0, file, 24, 4, 685);
			attr_dev(div1, "class", "gallery columns");
			add_location(div1, file, 27, 12, 825);
			attr_dev(div2, "class", "container");
			add_location(div2, file, 26, 8, 788);
			attr_dev(div3, "class", "modal-content svelte-hxqu00");
			add_location(div3, file, 25, 4, 751);
			attr_dev(button, "class", "modal-close is-large");
			attr_dev(button, "aria-label", "close");
			add_location(button, file, 36, 4, 1114);
			attr_dev(div4, "id", "galeria-interactiva");
			attr_dev(div4, "class", "modal");
			add_location(div4, file, 23, 0, 635);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			append_dev(div4, t0);
			append_dev(div4, div3);
			append_dev(div3, div2);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(div4, t1);
			append_dev(div4, button);

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*closeGallery*/ ctx[1], false, false, false),
					listen_dev(button, "click", /*closeGallery*/ ctx[1], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*images*/ 1) {
				each_value = /*images*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { images } = $$props;

	const closeGallery = () => {
		document.querySelector("#galeria-interactiva").classList.toggle("is-active");
	};

	onMount(async () => {
		let { tns } = await import('./tiny-slider.bd92118a.js');

		let slider = tns({
			container: ".gallery",
			items: 1,
			slideBy: "page",
			autoplay: false,
			mouseDrag: true
		});
	});

	const writable_props = ["images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlideShow> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("SlideShow", $$slots, []);

	$$self.$set = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	$$self.$capture_state = () => ({ onMount, images, closeGallery });

	$$self.$inject_state = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [images, closeGallery];
}

class SlideShow extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { images: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SlideShow",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*images*/ ctx[0] === undefined && !("images" in props)) {
			console.warn("<SlideShow> was created without expected prop 'images'");
		}
	}

	get images() {
		throw new Error("<SlideShow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<SlideShow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\StandB.svelte generated by Svelte v3.23.0 */
const file$1 = "src\\components\\StandB.svelte";

// (58:4) {#if stand.pdf}
function create_if_block(ctx) {
	let div;
	let a;
	let t;
	let a_href_value;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t = text("Sobre Nosotros");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { target: true, href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "Sobre Nosotros");
			a_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "target", "_blank");
			attr_dev(a, "href", a_href_value = /*stand*/ ctx[0].pdf);
			attr_dev(a, "class", "button is-rounded is-primary is-outlined is-uppercase has-pdf svelte-xjrdx");
			add_location(a, file$1, 59, 8, 1799);
			attr_dev(div, "class", "pdf-trigger");
			add_location(div, file$1, 58, 4, 1764);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*stand*/ 1 && a_href_value !== (a_href_value = /*stand*/ ctx[0].pdf)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(58:4) {#if stand.pdf}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div2;
	let div0;
	let a;
	let t0;
	let a_href_value;
	let t1;
	let iframe;
	let iframe_title_value;
	let iframe_src_value;
	let t2;
	let div1;
	let button;
	let t3;
	let t4;
	let t5;
	let current;
	let mounted;
	let dispose;

	const slideshow = new SlideShow({
			props: { images: /*images*/ ctx[1] },
			$$inline: true
		});

	let if_block = /*stand*/ ctx[0].pdf && create_if_block(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			a = element("a");
			t0 = text("Conócenos");
			t1 = space();
			iframe = element("iframe");
			t2 = space();
			div1 = element("div");
			button = element("button");
			t3 = text("Galería");
			t4 = space();
			create_component(slideshow.$$.fragment);
			t5 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			a = claim_element(div0_nodes, "A", { href: true, target: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, "Conócenos");
			a_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);

			iframe = claim_element(div0_nodes, "IFRAME", {
				title: true,
				src: true,
				frameborder: true,
				allow: true,
				allowfullscreen: true,
				class: true
			});

			children(iframe).forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button = claim_element(div1_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t3 = claim_text(button_nodes, "Galería");
			button_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(div2_nodes);
			claim_component(slideshow.$$.fragment, div2_nodes);
			t5 = claim_space(div2_nodes);
			if (if_block) if_block.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", a_href_value = /*stand*/ ctx[0].website);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "class", "button is-rounded is-primary is-outlined is-uppercase has-iframe svelte-xjrdx");
			add_location(a, file$1, 44, 8, 1184);
			attr_dev(iframe, "title", iframe_title_value = /*stand*/ ctx[0].title);
			if (iframe.src !== (iframe_src_value = /*stand*/ ctx[0].iframe)) attr_dev(iframe, "src", iframe_src_value);
			attr_dev(iframe, "frameborder", "0");
			attr_dev(iframe, "allow", "autoplay; fullscreen");
			iframe.allowFullscreen = true;
			attr_dev(iframe, "class", "svelte-xjrdx");
			add_location(iframe, file$1, 45, 8, 1322);
			attr_dev(div0, "class", "iframe-container svelte-xjrdx");
			add_location(div0, file$1, 43, 4, 1144);
			attr_dev(button, "class", "button is-rounded is-primary is-outlined is-uppercase has-gallery svelte-xjrdx");
			add_location(button, file$1, 52, 8, 1539);
			attr_dev(div1, "class", "gallery-trigger");
			add_location(div1, file$1, 51, 4, 1500);
			attr_dev(div2, "class", "controls svelte-xjrdx");
			add_location(div2, file$1, 41, 0, 1083);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, a);
			append_dev(a, t0);
			append_dev(div0, t1);
			append_dev(div0, iframe);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div1, button);
			append_dev(button, t3);
			append_dev(div2, t4);
			mount_component(slideshow, div2, null);
			append_dev(div2, t5);
			if (if_block) if_block.m(div2, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*openGallery*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*stand*/ 1 && a_href_value !== (a_href_value = /*stand*/ ctx[0].website)) {
				attr_dev(a, "href", a_href_value);
			}

			if (!current || dirty & /*stand*/ 1 && iframe_title_value !== (iframe_title_value = /*stand*/ ctx[0].title)) {
				attr_dev(iframe, "title", iframe_title_value);
			}

			if (!current || dirty & /*stand*/ 1 && iframe.src !== (iframe_src_value = /*stand*/ ctx[0].iframe)) {
				attr_dev(iframe, "src", iframe_src_value);
			}

			if (/*stand*/ ctx[0].pdf) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div2, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(slideshow.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(slideshow.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(slideshow);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { stand } = $$props;
	let images = stand.gallery;

	const openGallery = () => {
		document.querySelector("#galeria-interactiva").classList.toggle("is-active");
	};

	const writable_props = ["stand"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StandB> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("StandB", $$slots, []);

	$$self.$set = $$props => {
		if ("stand" in $$props) $$invalidate(0, stand = $$props.stand);
	};

	$$self.$capture_state = () => ({ SlideShow, stand, images, openGallery });

	$$self.$inject_state = $$props => {
		if ("stand" in $$props) $$invalidate(0, stand = $$props.stand);
		if ("images" in $$props) $$invalidate(1, images = $$props.images);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [stand, images, openGallery];
}

class StandB extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { stand: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StandB",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stand*/ ctx[0] === undefined && !("stand" in props)) {
			console.warn("<StandB> was created without expected prop 'stand'");
		}
	}

	get stand() {
		throw new Error("<StandB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stand(value) {
		throw new Error("<StandB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\StandA.svelte generated by Svelte v3.23.0 */
const file$2 = "src\\components\\StandA.svelte";

// (49:4) {#if stand.iframe}
function create_if_block_3(ctx) {
	let div;
	let a;
	let t0;
	let a_href_value;
	let t1;
	let iframe;
	let iframe_title_value;
	let iframe_src_value;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t0 = text("Conócenos");
			t1 = space();
			iframe = element("iframe");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { href: true, target: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, "Conócenos");
			a_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);

			iframe = claim_element(div_nodes, "IFRAME", {
				title: true,
				src: true,
				frameborder: true,
				allow: true,
				allowfullscreen: true,
				class: true
			});

			children(iframe).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", a_href_value = /*stand*/ ctx[0].website);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "class", "button is-rounded is-primary is-outlined is-uppercase has-iframe svelte-1ezxxf2");
			add_location(a, file$2, 50, 8, 1436);
			attr_dev(iframe, "title", iframe_title_value = /*stand*/ ctx[0].title);
			if (iframe.src !== (iframe_src_value = /*stand*/ ctx[0].iframe)) attr_dev(iframe, "src", iframe_src_value);
			attr_dev(iframe, "frameborder", "0");
			attr_dev(iframe, "allow", "autoplay; fullscreen");
			iframe.allowFullscreen = true;
			attr_dev(iframe, "class", "svelte-1ezxxf2");
			add_location(iframe, file$2, 51, 8, 1574);
			attr_dev(div, "class", "iframe-container svelte-1ezxxf2");
			add_location(div, file$2, 49, 4, 1396);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t0);
			append_dev(div, t1);
			append_dev(div, iframe);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*stand*/ 1 && a_href_value !== (a_href_value = /*stand*/ ctx[0].website)) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*stand*/ 1 && iframe_title_value !== (iframe_title_value = /*stand*/ ctx[0].title)) {
				attr_dev(iframe, "title", iframe_title_value);
			}

			if (dirty & /*stand*/ 1 && iframe.src !== (iframe_src_value = /*stand*/ ctx[0].iframe)) {
				attr_dev(iframe, "src", iframe_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(49:4) {#if stand.iframe}",
		ctx
	});

	return block;
}

// (57:4) {#if stand.gallery}
function create_if_block_2(ctx) {
	let div;
	let button;
	let i;
	let t;
	let current;
	let mounted;
	let dispose;

	const slideshow = new SlideShow({
			props: { images: /*images*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			i = element("i");
			t = space();
			create_component(slideshow.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button = claim_element(div_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			i = claim_element(button_nodes, "I", { "data-feather": true, class: true });
			children(i).forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(slideshow.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "data-feather", "image");
			attr_dev(i, "class", "svelte-1ezxxf2");
			add_location(i, file$2, 58, 102, 1918);
			attr_dev(button, "class", "button is-primary is-outlined is-uppercase has-gallery svelte-1ezxxf2");
			add_location(button, file$2, 58, 8, 1824);
			attr_dev(div, "class", "gallery-trigger svelte-1ezxxf2");
			add_location(div, file$2, 57, 4, 1785);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, i);
			insert_dev(target, t, anchor);
			mount_component(slideshow, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*openGallery*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(slideshow.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(slideshow.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t);
			destroy_component(slideshow, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(57:4) {#if stand.gallery}",
		ctx
	});

	return block;
}

// (64:4) {#if stand.pdf}
function create_if_block_1(ctx) {
	let div;
	let a;
	let t;
	let a_href_value;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t = text("Sobre Nosotros");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { target: true, href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "Sobre Nosotros");
			a_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "target", "_blank");
			attr_dev(a, "href", a_href_value = /*stand*/ ctx[0].pdf);
			attr_dev(a, "class", "button is-rounded is-primary is-outlined is-uppercase has-pdf svelte-1ezxxf2");
			add_location(a, file$2, 65, 8, 2103);
			attr_dev(div, "class", "pdf-trigger svelte-1ezxxf2");
			add_location(div, file$2, 64, 4, 2068);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*stand*/ 1 && a_href_value !== (a_href_value = /*stand*/ ctx[0].pdf)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(64:4) {#if stand.pdf}",
		ctx
	});

	return block;
}

// (70:4) {#if stand.pdf}
function create_if_block$1(ctx) {
	let div;
	let a;
	let t;
	let a_href_value;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t = text("Punto de Contácto");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { target: true, href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "Punto de Contácto");
			a_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "target", "_blank");
			attr_dev(a, "href", a_href_value = /*stand*/ ctx[0].pdf);
			attr_dev(a, "class", "button is-rounded is-primary is-outlined is-uppercase has-chat svelte-1ezxxf2");
			add_location(a, file$2, 71, 8, 2345);
			attr_dev(div, "class", "chat-trigger svelte-1ezxxf2");
			add_location(div, file$2, 70, 4, 2309);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*stand*/ 1 && a_href_value !== (a_href_value = /*stand*/ ctx[0].pdf)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(70:4) {#if stand.pdf}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let current;
	let if_block0 = /*stand*/ ctx[0].iframe && create_if_block_3(ctx);
	let if_block1 = /*stand*/ ctx[0].gallery && create_if_block_2(ctx);
	let if_block2 = /*stand*/ ctx[0].pdf && create_if_block_1(ctx);
	let if_block3 = /*stand*/ ctx[0].pdf && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block3) if_block3.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "controls svelte-1ezxxf2");
			add_location(div, file$2, 46, 0, 1311);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t2);
			if (if_block3) if_block3.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*stand*/ ctx[0].iframe) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*stand*/ ctx[0].gallery) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*stand*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*stand*/ ctx[0].pdf) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*stand*/ ctx[0].pdf) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$1(ctx);
					if_block3.c();
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { stand } = $$props;
	let images = stand.gallery;

	const openGallery = () => {
		document.querySelector("#galeria-interactiva").classList.toggle("is-active");
	};

	const writable_props = ["stand"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StandA> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("StandA", $$slots, []);

	$$self.$set = $$props => {
		if ("stand" in $$props) $$invalidate(0, stand = $$props.stand);
	};

	$$self.$capture_state = () => ({ SlideShow, stand, images, openGallery });

	$$self.$inject_state = $$props => {
		if ("stand" in $$props) $$invalidate(0, stand = $$props.stand);
		if ("images" in $$props) $$invalidate(1, images = $$props.images);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [stand, images, openGallery];
}

class StandA extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { stand: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StandA",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stand*/ ctx[0] === undefined && !("stand" in props)) {
			console.warn("<StandA> was created without expected prop 'stand'");
		}
	}

	get stand() {
		throw new Error("<StandA>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stand(value) {
		throw new Error("<StandA>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Admin.svelte generated by Svelte v3.23.0 */

function create_fragment$3(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	const params = new URLSearchParams(window.location.search);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Admin> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Admin", $$slots, []);
	$$self.$capture_state = () => ({ params });
	return [];
}

class Admin extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Admin",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src\routes\medios\[slug].svelte generated by Svelte v3.23.0 */
const file$3 = "src\\routes\\medios\\[slug].svelte";

// (55:2) {:else}
function create_else_block(ctx) {
	let current;

	const standb = new StandB({
			props: { stand: /*stand*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(standb.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(standb.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(standb, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const standb_changes = {};
			if (dirty & /*stand*/ 1) standb_changes.stand = /*stand*/ ctx[0];
			standb.$set(standb_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(standb.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(standb.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(standb, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(55:2) {:else}",
		ctx
	});

	return block;
}

// (53:2) {#if stand.type === 'a'}
function create_if_block$2(ctx) {
	let current;

	const standa = new StandA({
			props: { stand: /*stand*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(standa.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(standa.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(standa, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const standa_changes = {};
			if (dirty & /*stand*/ 1) standa_changes.stand = /*stand*/ ctx[0];
			standa.$set(standa_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(standa.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(standa.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(standa, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(53:2) {#if stand.type === 'a'}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let title_value;
	let t0;
	let t1;
	let section;
	let div0;
	let current_block_type_index;
	let if_block;
	let t2;
	let div2;
	let div1;
	let a;
	let span0;
	let i;
	let span1;
	let t3;
	let current;
	document.title = title_value = "" + (/*stand*/ ctx[0].title + " - FIMPU");
	const admin = new Admin({ $$inline: true });
	const if_block_creators = [create_if_block$2, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*stand*/ ctx[0].type === "a") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			t0 = space();
			create_component(admin.$$.fragment);
			t1 = space();
			section = element("section");
			div0 = element("div");
			if_block.c();
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			a = element("a");
			span0 = element("span");
			i = element("i");
			span1 = element("span");
			t3 = text("Volver a Medios");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1nao22u\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(admin.$$.fragment, nodes);
			t1 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { id: true, class: true, style: true });
			var section_nodes = children(section);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			div2 = claim_element(section_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			a = claim_element(div1_nodes, "A", { href: true, id: true, class: true });
			var a_nodes = children(a);
			span0 = claim_element(a_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			i = claim_element(span0_nodes, "I", { "data-feather": true });
			children(i).forEach(detach_dev);
			span0_nodes.forEach(detach_dev);
			span1 = claim_element(a_nodes, "SPAN", {});
			var span1_nodes = children(span1);
			t3 = claim_text(span1_nodes, "Volver a Medios");
			span1_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "hero-body");
			add_location(div0, file$3, 51, 1, 1220);
			attr_dev(i, "data-feather", "chevrons-left");
			add_location(i, file$3, 60, 108, 1500);
			attr_dev(span0, "class", "icon is-small svelte-18mmk5o");
			add_location(span0, file$3, 60, 80, 1472);
			add_location(span1, file$3, 61, 46, 1549);
			attr_dev(a, "href", "/medios");
			attr_dev(a, "id", "volver");
			attr_dev(a, "class", "button is-primary has-margin-bottom-50 svelte-18mmk5o");
			add_location(a, file$3, 60, 3, 1395);
			attr_dev(div1, "class", "container");
			add_location(div1, file$3, 59, 2, 1368);
			attr_dev(div2, "class", "hero-footer");
			add_location(div2, file$3, 58, 1, 1340);
			attr_dev(section, "id", "stand");
			attr_dev(section, "class", "hero is-fullheight svelte-18mmk5o");
			set_style(section, "background", "url(" + /*stand*/ ctx[0].background + ")");
			add_location(section, file$3, 50, 0, 1128);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(admin, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(section, t2);
			append_dev(section, div2);
			append_dev(div2, div1);
			append_dev(div1, a);
			append_dev(a, span0);
			append_dev(span0, i);
			append_dev(a, span1);
			append_dev(span1, t3);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*stand*/ 1) && title_value !== (title_value = "" + (/*stand*/ ctx[0].title + " - FIMPU"))) {
				document.title = title_value;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			if (!current || dirty & /*stand*/ 1) {
				set_style(section, "background", "url(" + /*stand*/ ctx[0].background + ")");
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(admin.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(admin.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(admin, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(section);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload({ params, query }) {
	// the `slug` parameter is available because
	// this file is called [slug].svelte
	const res = await this.fetch(`medios/${params.slug}.json`);

	const data = await res.json();

	if (res.status === 200) {
		return { stand: data };
	} else {
		this.error(res.status, data.message);
	}
}

function instance$4($$self, $$props, $$invalidate) {
	let { stand } = $$props;
	const writable_props = ["stand"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Bslugu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Bslugu5D", $$slots, []);

	$$self.$set = $$props => {
		if ("stand" in $$props) $$invalidate(0, stand = $$props.stand);
	};

	$$self.$capture_state = () => ({ Admin, StandA, StandB, preload, stand });

	$$self.$inject_state = $$props => {
		if ("stand" in $$props) $$invalidate(0, stand = $$props.stand);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [stand];
}

class U5Bslugu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { stand: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bslugu5D",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stand*/ ctx[0] === undefined && !("stand" in props)) {
			console.warn("<U5Bslugu5D> was created without expected prop 'stand'");
		}
	}

	get stand() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stand(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bslugu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW3NsdWddLjhlZjFiMGY0LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9TbGlkZVNob3cuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvU3RhbmRCLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1N0YW5kQS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9BZG1pbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL21lZGlvcy9bc2x1Z10uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgICBpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSdcclxuICAgXHJcbiAgICBleHBvcnQgbGV0IGltYWdlc1xyXG5cclxuICAgIGNvbnN0IGNsb3NlR2FsbGVyeSA9ICgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FsZXJpYS1pbnRlcmFjdGl2YScpLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgb25Nb3VudCggYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGxldCB7IHRucyB9ID0gYXdhaXQgaW1wb3J0KFwidGlueS1zbGlkZXIvc3JjL3Rpbnktc2xpZGVyXCIpIFxyXG4gICAgICAgIGxldCBzbGlkZXIgPSB0bnMoeyBjb250YWluZXI6ICcuZ2FsbGVyeScsIGl0ZW1zOiAxLCBzbGlkZUJ5OiAncGFnZScsIGF1dG9wbGF5OiBmYWxzZSwgbW91c2VEcmFnOiB0cnVlfSlcclxuICAgIH0pXHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XHJcbiAgICAubW9kYWwtY29udGVudCB7XHJcbiAgICAgICAgd2lkdGg6IDkwdnc7XHJcbiAgICAgICAgaGVpZ2h0OiA5MHZoO1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgfVxyXG48L3N0eWxlPlxyXG5cclxuPGRpdiBpZD1cImdhbGVyaWEtaW50ZXJhY3RpdmFcIiBjbGFzcz1cIm1vZGFsXCI+XHJcbiAgICA8ZGl2IG9uOmNsaWNrPXtjbG9zZUdhbGxlcnl9IGNsYXNzPVwibW9kYWwtYmFja2dyb3VuZFwiPjwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnYWxsZXJ5IGNvbHVtbnNcIj5cclxuICAgICAgICAgICAgICAgIHsjZWFjaCBpbWFnZXMgYXMgaW1hZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0gY29sdW1uIGlzLTEyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwie2ltYWdlfVwiIGFsdD1cIntpbWFnZX1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxidXR0b24gb246Y2xpY2s9e2Nsb3NlR2FsbGVyeX0gY2xhc3M9XCJtb2RhbC1jbG9zZSBpcy1sYXJnZVwiIGFyaWEtbGFiZWw9XCJjbG9zZVwiPjwvYnV0dG9uPlxyXG48L2Rpdj4iLCI8c2NyaXB0PlxyXG4gICAgaW1wb3J0IFNsaWRlU2hvdyBmcm9tIFwiLi9TbGlkZVNob3cuc3ZlbHRlXCJcclxuICAgIGV4cG9ydCBsZXQgc3RhbmRcclxuICAgIFxyXG4gICAgbGV0IGltYWdlcyA9IHN0YW5kLmdhbGxlcnlcclxuICAgIGNvbnN0IG9wZW5HYWxsZXJ5ID0gKCkgPT4ge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNnYWxlcmlhLWludGVyYWN0aXZhJykuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJylcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cclxuICAgIC5pZnJhbWUtY29udGFpbmVyIHtcclxuICAgICAgICAkbWVhc3VyZTogNTV2aDtcclxuICAgICAgICB3aWR0aDogJG1lYXN1cmU7XHJcbiAgICAgICAgaGVpZ2h0OiAkbWVhc3VyZTtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgdG9wOiA2MCU7XHJcbiAgICAgICAgbGVmdDogNDclO1xyXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xyXG5cclxuICAgICAgICBpZnJhbWUge1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgaGVpZ2h0OiA1NiU7XHJcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCA2MHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLmNvbnRyb2xzIC5idXR0b24ge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG5cclxuICAgICAgICAmLmlzLXByaW1hcnkuaXMtb3V0bGluZWQge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS44dmg7XHJcblxyXG4gICAgICAgICAgICAmLmhhcy1pZnJhbWUge1xyXG4gICAgICAgICAgICAgICAgdG9wOiAtOHZoO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQ6MDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJi5oYXMtZ2FsbGVyeSB7XHJcbiAgICAgICAgICAgICAgICBib3R0b206IDMwdmg7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAxNXZ3O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAmLmhhcy1wZGYge1xyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAzMHZoO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDE1dnc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcblxyXG48ZGl2IGNsYXNzPVwiY29udHJvbHNcIj5cclxuICAgIDwhLS0gVmlkZW8gLS0gQ29uw7NjZW5vcyAtLT5cclxuICAgIDxkaXYgY2xhc3M9XCJpZnJhbWUtY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGEgaHJlZj1cIntzdGFuZC53ZWJzaXRlfVwiIHRhcmdldD1cIl9ibGFua1wiIGNsYXNzPVwiYnV0dG9uIGlzLXJvdW5kZWQgaXMtcHJpbWFyeSBpcy1vdXRsaW5lZCBpcy11cHBlcmNhc2UgaGFzLWlmcmFtZVwiPkNvbsOzY2Vub3M8L2E+XHJcbiAgICAgICAgPGlmcmFtZSB0aXRsZT1cIntzdGFuZC50aXRsZX1cIiBzcmM9XCJ7c3RhbmQuaWZyYW1lfVwiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93PVwiYXV0b3BsYXk7IGZ1bGxzY3JlZW5cIlxyXG4gICAgICAgICAgICBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8IS0tIEdhbGVyw61hIC0tPlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LXRyaWdnZXJcIj5cclxuICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXtvcGVuR2FsbGVyeX0gY2xhc3M9XCJidXR0b24gaXMtcm91bmRlZCBpcy1wcmltYXJ5IGlzLW91dGxpbmVkIGlzLXVwcGVyY2FzZSBoYXMtZ2FsbGVyeVwiPkdhbGVyw61hPC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxTbGlkZVNob3cge2ltYWdlc30vPlxyXG5cclxuICAgIDwhLS0gUERGIC0tIFNvYnJlIE5vc290cm9zIC0tPlxyXG4gICAgeyNpZiBzdGFuZC5wZGZ9XHJcbiAgICA8ZGl2IGNsYXNzPVwicGRmLXRyaWdnZXJcIj5cclxuICAgICAgICA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPXtzdGFuZC5wZGZ9IGNsYXNzPVwiYnV0dG9uIGlzLXJvdW5kZWQgaXMtcHJpbWFyeSBpcy1vdXRsaW5lZCBpcy11cHBlcmNhc2UgaGFzLXBkZlwiPlNvYnJlIE5vc290cm9zPC9hPlxyXG4gICAgPC9kaXY+XHJcbiAgICB7L2lmfVxyXG48L2Rpdj5cclxuIiwiPHNjcmlwdD5cclxuICAgIGltcG9ydCBTbGlkZVNob3cgZnJvbSBcIi4vU2xpZGVTaG93LnN2ZWx0ZVwiXHJcbiAgICBleHBvcnQgbGV0IHN0YW5kXHJcbiAgICBcclxuICAgIGxldCBpbWFnZXMgPSBzdGFuZC5nYWxsZXJ5XHJcbiAgICBjb25zdCBvcGVuR2FsbGVyeSA9ICgpID0+IHtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FsZXJpYS1pbnRlcmFjdGl2YScpLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpXHJcbiAgICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XHJcbiAgICAuaWZyYW1lLWNvbnRhaW5lciB7XHJcbiAgICAgICAgJG1lYXN1cmU6IDU1dmg7XHJcbiAgICAgICAgd2lkdGg6ICRtZWFzdXJlO1xyXG4gICAgICAgIGhlaWdodDogJG1lYXN1cmU7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIHRvcDogNTUlO1xyXG4gICAgICAgIGxlZnQ6IDcwJTtcclxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcclxuXHJcbiAgICAgICAgaWZyYW1lIHtcclxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgICAgIGhlaWdodDogNTYlO1xyXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xyXG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNjBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5jb250cm9scyAuYnV0dG9uIHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuXHJcbiAgICAgICAgJi5pcy1wcmltYXJ5LmlzLW91dGxpbmVkIHtcclxuICAgICAgICAgICAgJjpob3Zlciw6YWN0aXZlIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICM1MDBBREE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgICAgICBmb250LXNpemU6IDEuOHZoO1xyXG5cclxuICAgICAgICAgICAgJi5oYXMtaWZyYW1lIHtcclxuICAgICAgICAgICAgICAgIHRvcDogLTh2aDtcclxuICAgICAgICAgICAgICAgIHJpZ2h0OjA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICYuaGFzLWdhbGxlcnkge1xyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAzMnZoO1xyXG4gICAgICAgICAgICAgICAgbGVmdDogMTYuNXZ3O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAmLmhhcy1jaGF0IHtcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogMzB2aDtcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiAxNXZ3O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAmLmhhcy1wZGYge1xyXG4gICAgICAgICAgICAgICAgdG9wOiAyNXZoO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDQ1dnc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcblxyXG48ZGl2IGNsYXNzPVwiY29udHJvbHNcIj5cclxuICAgIDwhLS0gVmlkZW8gLS0gQ29uw7NjZW5vcyAtLT5cclxuICAgIHsjaWYgc3RhbmQuaWZyYW1lfVxyXG4gICAgPGRpdiBjbGFzcz1cImlmcmFtZS1jb250YWluZXJcIj5cclxuICAgICAgICA8YSBocmVmPVwie3N0YW5kLndlYnNpdGV9XCIgdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3M9XCJidXR0b24gaXMtcm91bmRlZCBpcy1wcmltYXJ5IGlzLW91dGxpbmVkIGlzLXVwcGVyY2FzZSBoYXMtaWZyYW1lXCI+Q29uw7NjZW5vczwvYT5cclxuICAgICAgICA8aWZyYW1lIHRpdGxlPVwie3N0YW5kLnRpdGxlfVwiIHNyYz1cIntzdGFuZC5pZnJhbWV9XCIgZnJhbWVib3JkZXI9XCIwXCIgYWxsb3c9XCJhdXRvcGxheTsgZnVsbHNjcmVlblwiXHJcbiAgICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4gXHJcbiAgICA8L2Rpdj5cclxuICAgIHsvaWZ9XHJcbiAgICA8IS0tIEdhbGVyw61hIC0tPlxyXG4gICAgeyNpZiBzdGFuZC5nYWxsZXJ5fVxyXG4gICAgPGRpdiBjbGFzcz1cImdhbGxlcnktdHJpZ2dlclwiPlxyXG4gICAgICAgIDxidXR0b24gb246Y2xpY2s9e29wZW5HYWxsZXJ5fSBjbGFzcz1cImJ1dHRvbiBpcy1wcmltYXJ5IGlzLW91dGxpbmVkIGlzLXVwcGVyY2FzZSBoYXMtZ2FsbGVyeVwiPjxpIGRhdGEtZmVhdGhlcj1cImltYWdlXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8U2xpZGVTaG93IHtpbWFnZXN9Lz5cclxuICAgIHsvaWZ9XHJcbiAgICA8IS0tIFBERiAtLSBTb2JyZSBOb3NvdHJvcyAtLT5cclxuICAgIHsjaWYgc3RhbmQucGRmfVxyXG4gICAgPGRpdiBjbGFzcz1cInBkZi10cmlnZ2VyXCI+XHJcbiAgICAgICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17c3RhbmQucGRmfSBjbGFzcz1cImJ1dHRvbiBpcy1yb3VuZGVkIGlzLXByaW1hcnkgaXMtb3V0bGluZWQgaXMtdXBwZXJjYXNlIGhhcy1wZGZcIj5Tb2JyZSBOb3NvdHJvczwvYT5cclxuICAgIDwvZGl2PlxyXG4gICAgey9pZn1cclxuICAgIDwhLS0gUERGIC0tIENoYXQgTW9kYWwgLS0+XHJcbiAgICB7I2lmIHN0YW5kLnBkZn1cclxuICAgIDxkaXYgY2xhc3M9XCJjaGF0LXRyaWdnZXJcIj5cclxuICAgICAgICA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPXtzdGFuZC5wZGZ9IGNsYXNzPVwiYnV0dG9uIGlzLXJvdW5kZWQgaXMtcHJpbWFyeSBpcy1vdXRsaW5lZCBpcy11cHBlcmNhc2UgaGFzLWNoYXRcIj5QdW50byBkZSBDb250w6FjdG88L2E+XHJcbiAgICA8L2Rpdj5cclxuICAgIHsvaWZ9XHJcbiAgICBcclxuPC9kaXY+XHJcbiIsIjxzY3JpcHQ+XHJcbiAgICAvKipcclxuICAgICAqIEVzdGUgY29tcG9uZW50ZSBleGlzdGUgcGFyYSB2YWxpZGFyIGRlIGZvcm1hIGxpbXBpYSBcclxuICAgICAqIG1lZGlhbnRlIHF1ZXJ5U3RyaW5ncyBzaSB1biB1c3VhcmlvIHF1aWVyZSBhZG1pbmlzdHJhclxyXG4gICAgKi9cclxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaClcclxuXHJcbjwvc2NyaXB0PiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuXG5cdGltcG9ydCBBZG1pbiBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9BZG1pbi5zdmVsdGVcIlxuXHRpbXBvcnQgU3RhbmRBIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvU3RhbmRBLnN2ZWx0ZSdcblx0aW1wb3J0IFN0YW5kQiBmcm9tICcuLi8uLi9jb21wb25lbnRzL1N0YW5kQi5zdmVsdGUnXG5cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoe1xuXHRcdHBhcmFtcyxcblx0XHRxdWVyeVxuXHR9KSB7XG5cdFx0Ly8gdGhlIGBzbHVnYCBwYXJhbWV0ZXIgaXMgYXZhaWxhYmxlIGJlY2F1c2Vcblx0XHQvLyB0aGlzIGZpbGUgaXMgY2FsbGVkIFtzbHVnXS5zdmVsdGVcblx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKGBtZWRpb3MvJHtwYXJhbXMuc2x1Z30uanNvbmApO1xuXHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuXG5cdFx0aWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3RhbmQ6IGRhdGFcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZXJyb3IocmVzLnN0YXR1cywgZGF0YS5tZXNzYWdlKTtcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cblx0I3N0YW5kIHtcblx0XHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20gIWltcG9ydGFudDtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyICFpbXBvcnRhbnQ7XG5cdFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdCAhaW1wb3J0YW50O1xuXHR9XG5cblx0JGdyYWRpZW50OiBsaW5lYXItZ3JhZGllbnQoNzFkZWcsIHJnYmEoMTYxLCAwLCAyMjQsIDEpIDAlLCByZ2JhKDIzMSwgNjAsIDQxLCAxKSAxMDAlKTtcblxuXHQuYnV0dG9uI3ZvbHZlciB7XG5cdFx0YmFja2dyb3VuZDogJGdyYWRpZW50O1xuXG5cdFx0Lmljb24ge1xuXHRcdFx0YmFja2dyb3VuZDogd2hpdGU7XG5cdFx0XHRjb2xvcjogYmxhY2s7XG5cdFx0XHRoZWlnaHQ6IDUwcHg7XG5cdFx0XHR3aWR0aDogNTBweDtcblx0XHRcdG1hcmdpbi1sZWZ0OiAtMjVweDtcblx0XHRcdG1hcmdpbi1yaWdodDogMjBweDtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG5cdGV4cG9ydCBsZXQgc3RhbmQ7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e3N0YW5kLnRpdGxlfSAtIEZJTVBVPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxBZG1pbi8+XG48c2VjdGlvbiBpZD1cInN0YW5kXCIgY2xhc3M9XCJoZXJvIGlzLWZ1bGxoZWlnaHRcIiBzdHlsZT1cImJhY2tncm91bmQ6dXJsKHtzdGFuZC5iYWNrZ3JvdW5kfSlcIj5cblx0PGRpdiBjbGFzcz1cImhlcm8tYm9keVwiPlxuXHRcdHsjaWYgc3RhbmQudHlwZSA9PT0gJ2EnfVxuXHRcdFx0PFN0YW5kQSB7c3RhbmR9Lz5cblx0XHR7OmVsc2V9XG5cdFx0XHQ8U3RhbmRCIHtzdGFuZH0vPlxuXHRcdHsvaWZ9XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzPVwiaGVyby1mb290ZXJcIj5cblx0XHQ8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG5cdFx0XHQ8YSBocmVmPVwiL21lZGlvc1wiIGlkPVwidm9sdmVyXCIgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBoYXMtbWFyZ2luLWJvdHRvbS01MFwiPjxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbFwiPjxpXG5cdFx0XHRcdFx0XHRkYXRhLWZlYXRoZXI9XCJjaGV2cm9ucy1sZWZ0XCI+PC9pPjwvc3Bhbj48c3Bhbj5Wb2x2ZXIgYSBNZWRpb3M8L3NwYW4+PC9hPlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvc2VjdGlvbj4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OENBOEJtQyxHQUFLO2tEQUFTLEdBQUs7Ozs7Ozs7Ozs7O3NFQUFuQixHQUFLOzs7OzRFQUFTLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBRi9CLEdBQU07Ozs7Z0NBQVgsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBSkgsR0FBWTtrREFZVCxHQUFZOzs7Ozs7Ozs0QkFSWCxHQUFNOzs7OytCQUFYLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXpCUCxNQUFNOztPQUVYLFlBQVk7RUFDZCxRQUFRLENBQUMsYUFBYSxDQUFDLHNCQUFzQixFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVzs7O0NBRy9FLE9BQU87UUFDRyxHQUFHLGtCQUFrQiwyQkFBNkI7O01BQ3BELE1BQU0sR0FBRyxHQUFHO0dBQUcsU0FBUyxFQUFFLFVBQVU7R0FBRSxLQUFLLEVBQUUsQ0FBQztHQUFFLE9BQU8sRUFBRSxNQUFNO0dBQUUsUUFBUSxFQUFFLEtBQUs7R0FBRSxTQUFTLEVBQUUsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnRENnRDVFLEdBQUssSUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7eUVBQVQsR0FBSyxJQUFDLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFGakMsR0FBSyxJQUFDLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBYkEsR0FBSyxJQUFDLE9BQU87Ozs7NERBQ1AsR0FBSyxJQUFDLEtBQUs7b0RBQVMsR0FBSyxJQUFDLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswREFPOUIsR0FBVzs7Ozs7cUZBUm5CLEdBQUssSUFBQyxPQUFPOzs7O2lHQUNQLEdBQUssSUFBQyxLQUFLOzs7O3VGQUFTLEdBQUssSUFBQyxNQUFNOzs7O2lCQVkvQyxHQUFLLElBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXZESCxLQUFLO0tBRVosTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPOztPQUNwQixXQUFXO0VBQ2IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxzQkFBc0IsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREM0Q2pFLEdBQUssSUFBQyxPQUFPOzs7OzREQUNQLEdBQUssSUFBQyxLQUFLO29EQUFTLEdBQUssSUFBQyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozt5RUFEdEMsR0FBSyxJQUFDLE9BQU87Ozs7cUZBQ1AsR0FBSyxJQUFDLEtBQUs7Ozs7MkVBQVMsR0FBSyxJQUFDLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswREFPOUIsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQU9KLEdBQUssSUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7eUVBQVQsR0FBSyxJQUFDLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBTVQsR0FBSyxJQUFDLEdBQUc7Ozs7Ozs7Ozs7Ozt5RUFBVCxHQUFLLElBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBdkJqQyxHQUFLLElBQUMsTUFBTTsyQkFRWixHQUFLLElBQUMsT0FBTzsyQkFPYixHQUFLLElBQUMsR0FBRzsyQkFNVCxHQUFLLElBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFyQlQsR0FBSyxJQUFDLE1BQU07Ozs7Ozs7Ozs7Ozs7aUJBUVosR0FBSyxJQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQU9iLEdBQUssSUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7O2lCQU1ULEdBQUssSUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbkVILEtBQUs7S0FFWixNQUFNLEdBQUcsS0FBSyxDQUFDLE9BQU87O09BQ3BCLFdBQVc7RUFDYixRQUFRLENBQUMsYUFBYSxDQUFDLHNCQUFzQixFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09DRHpFLE1BQU0sT0FBTyxlQUFlLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RDeUNwRCxHQUFLLElBQUMsS0FBSzs7Ozs7O2dCQU1iLEdBQUssSUFBQyxJQUFJLEtBQUssR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dURBRjZDLEdBQUssSUFBQyxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkZBSjdFLEdBQUssSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REFJa0QsR0FBSyxJQUFDLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUE1Qy9ELE9BQU8sR0FDNUIsTUFBTSxFQUNOLEtBQUs7OztPQUlDLEdBQUcsU0FBUyxJQUFJLENBQUMsS0FBSyxXQUFXLE1BQU0sQ0FBQyxJQUFJOztPQUM1QyxJQUFJLFNBQVMsR0FBRyxDQUFDLElBQUk7O0tBRXZCLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRztXQUVwQixLQUFLLEVBQUUsSUFBSTs7RUFHWixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87Ozs7O09Bc0IxQixLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
